\documentclass[11pt]{beamer}

%% Zeichenkodierung

\usepackage[latin1]{inputenc}

%% Deutsches Sprachpaket
\usepackage[german]{babel}

%% Grafik-Einbindung
\usepackage{graphicx}

%% Mathe-Einbindung
\usepackage{amsmath,amsfonts,amssymb,bbm}

%% Schriftart ändern auf Computer Modern Sans Serif
\usepackage[T1]{fontenc}
\renewcommand*\familydefault{\sfdefault}

%% Beamer Template
\usetheme{Luebeck}

%% Navigationssymbole ausblenden
\setbeamertemplate{navigation symbols}{}

%% Seitenzahl und Gesamtanzahl in Fußleiste

\setbeamertemplate{footline}[frame number]

%% Metadaten des Dokuments
\title[RMQ]{Range Minimum Query}
\author{Michael Mardaus \and Felix Lauenroth}
\date{21. Mai 2013}

%% Einzug nach Absatz und Zwischenraum
\setlength{\parindent}{0pt}
\setlength{\parskip}{8pt}

%% Michaels Addons
\newcommand*{\Oh}{\mathcal{O}}

\begin{document}

\thispagestyle{empty}

\begin{frame}
  \titlepage
\end{frame}


\begin{frame}{Inhaltsverzeichnis}
\tableofcontents[pausesections]
\end{frame}

\section{Allgemeines}

\subsection{Überblick}

\begin{frame}{Überblick}
  \begin{definition}[Range Minimum Query]
    
    
    \[\text{RMQ}_{A}(\ell,r) = \text{arg} \ \min_{\ell \leq k \leq r } A[k] \]
    
  \pause
  \only<2->{
  In Worten:\\
  Gesucht ist der Index $k$ des kleinsten Elements $A[k]$ in einem gegebenen Bereich ($\ell\leq k\leq r$) innerhalb eines Arrays $A$.}
  \end{definition}
\end{frame}

\begin{frame}
\begin{block}{Beispiel 1}
  \includegraphics<1>[width=0.5\linewidth]{picture/1}%
  \includegraphics<2>[width=0.5\linewidth]{picture/2}%
  \includegraphics<3>[width=0.5\linewidth]{picture/3}%
\end{block}\end{frame}

\subsection{Naiver Ansatz}

\begin{frame}
\begin{block}{Idee 1 - trivial}
 Durch das gegebene Array (von $\ell$ bis $r$) durch iterieren und dabei das Minimum merken $\Rightarrow$ Querytime: $\Oh(n)$
\end{block}
 \pause
 \begin{block}{Idee 2 - mit Preprocessing}
 Preprocessing -- also das Aufbereiten eines zusätzlichen Arrays, für mehrere zukünftige Queries -- kann zu sublinearen Zugriffszeiten führen.\\
 Erste Idee: Abspeichern der Minima jeder Kombination von Intervallgrenzen in einer 2-dim. Matrix (á la Adjazenzmatrix)\\
 $\Rightarrow$ Preprocessingtime: $\Oh(n^3)$, Querytime: $\Oh(1)$
 \end{block}

 
\end{frame}

\begin{frame}[fragile]
\begin{block}{Idee 3 - mit dynamischer Programmierung}
Ähnliche Idee, allerdings mit dynamischer Programmierung im Preprocessing Schritt.\\
  $\Rightarrow$ Preprocessingtime: $\Oh(n^2)$, Querytime $\Oh(1)$.
\end{block}
\vspace{-6mm}
  \pause
  \begin{verbatim}
 void trivial3(int M[N][N], int A[N], int N){
      for (i = 0; i < N; i++)
          M[i][i] = i;
      for (i = 0; i < N; i++)
          for (j = i + 1; j < N; j++)
              if (A[M[i][j - 1]] < A[j])
                  M[i][j] = M[i][j - 1];
              else
                  M[i][j] = j;
  }
  \end{verbatim}
  \vspace{-5mm}
\end{frame}


\section{Effiziente Algorithmen}
\frame{\sectionpage}

\subsection{Speicheroptimiert}

\begin{frame}[fragile]
\begin{block}{$\sqrt n$ Teile Algo}

Algorithmus der das Array in $\sqrt n$ Teile teilt und von diesen Teilen jeweils das Minimum speichert.\\[5mm]
Bild\\[5mm]
$\Rightarrow$ Preprocessingtime: $\Oh(n)$, Querytime: $\Oh(\sqrt n)$
\end{block}
\end{frame}


\subsection{Zugriffsoptimiert}

\begin{frame}[fragile]
\begin{block}{Algo mit Sparse Table}
Algorithmus erstellt eine $n \times \log n$ Matrix in der Teilarrays der Länge $2^k$ per dynamischer Programmierung berechnet werden\\[5mm]
Bild von Array\\[5mm]

Code des dynmischen Programmierungschritts:
\vspace{-5mm}
\begin{verbatim}
if (A[M[i][j - 1]] < A[M[i + (1 << (j - 1))][j - 1]])
    M[i][j] = M[i][j - 1];
else
    M[i][j] = M[i + (1 << (j - 1))][j - 1];
\end{verbatim}
$\Rightarrow$ Preprocessingtime: $\Oh(n\cdot\log n)$, Querytime: $\Oh(1)$
\end{block}
\end{frame}

\begin{frame}
\begin{block}{Segment tree Algo}
Heap ähnliche Struktur \\
erklärendes Bild \\
$\Rightarrow$ Preprocessingtime: $\Oh(n)$, Querytime: $\Oh(\log n)$
\end{block}
\end{frame}

\section{Problemset}
\frame{\sectionpage}

\subsection{Beschreibung}

\begin{frame}
\begin{block}{Skyline-Problem}
Gesucht wird die größtmögliche, zusammenhängende, rechteckige Fläche innerhalb einer gegebenen Skyline.
\end{block}
\begin{center}
\includegraphics[height=0.6\textheight]{picture/skyline-test.png}
\end{center}
\vspace{-5mm}
\end{frame}

\subsection{Lösung}

\begin{frame}
Algorithmus:\\
\begin{enumerate}
\item Suchen des Minimums im aktuellen Intervall.
\end{enumerate}
\begin{columns}
\column{.50\textwidth}
\begin{center}
\includegraphics[height=0.4\textheight]{picture/algo-schritt1.png}
\end{center}
\column{.50\textwidth}
\begin{center}
\includegraphics[height=0.6\textheight]{picture/skyline-min-find.png}
\end{center}
\end{columns}
\vspace{-5mm}
\end{frame}

\begin{frame}
Algorithmus:\\
\begin{enumerate}
\setcounter{enumi}{1} 
\item Berechnen der Fläche unterhalb dieses Minimums (hier 14)
\end{enumerate}
\begin{columns}
\column{.50\textwidth}
\begin{center}
\includegraphics[height=0.4\textheight]{picture/algo-schritt2.png}
\end{center}
\column{.50\textwidth}
\begin{center}
\includegraphics[height=0.6\textheight]{picture/skyline-area1.png}
\end{center}
\end{columns}
\vspace{-5mm}
\end{frame}

\begin{frame}
Algorithmus:\\
\begin{enumerate}
\setcounter{enumi}{2} 
\item Teilen des Intervalls in rechtes und linkes Teilproblem
\end{enumerate}
\begin{columns}
\column{.50\textwidth}
\begin{center}
\includegraphics[height=0.4\textheight]{picture/algo-schritt3.png}
\end{center}
\column{.50\textwidth}
\begin{center}
\includegraphics[height=0.6\textheight]{picture/skyline-left-right1.png}
\end{center}
\end{columns}
\vspace{-5mm}
\end{frame}

\begin{frame}
Algorithmus:\\
\begin{enumerate}
\setcounter{enumi}{3} 
\item In diesen beiden Teilproblemen wieder Schritt 1 anwenden.
\end{enumerate}
\begin{columns}
\column{.50\textwidth}
\begin{center}
\includegraphics[height=0.4\textheight]{picture/algo-schritt4.png}
\end{center}
\column{.50\textwidth}
\begin{center}
\includegraphics[height=0.6\textheight]{picture/skyline-right1.png}
\end{center}
\end{columns}
\vspace{-5mm}
\end{frame}

\begin{frame}
Algorithmus 2. Runde:\\
\begin{enumerate}
\setcounter{enumi}{4}
\item Suchen des Minimums im aktuellen Intervall.
\end{enumerate}
\begin{columns}
\column{.50\textwidth}
\begin{center}
\includegraphics[height=0.4\textheight]{picture/algo-schritt1.png}
\end{center}
\column{.50\textwidth}
\begin{center}
\includegraphics[height=0.6\textheight]{picture/skyline-min-find2.png}
\end{center}
\end{columns}
\end{frame}

\begin{frame}
Algorithmus 2. Runde:\\
\begin{enumerate}
\setcounter{enumi}{5} 
\item Berechnen der Fläche unterhalb dieses Minimums (jetzt 15)
\end{enumerate}
\begin{columns}
\column{.50\textwidth}
\begin{center}
\includegraphics[height=0.4\textheight]{picture/algo-schritt2.png}
\end{center}
\column{.50\textwidth}
\begin{center}
\includegraphics[height=0.6\textheight]{picture/skyline-area2.png}
\end{center}
\end{columns}
\vspace{-5mm}
\end{frame}

\begin{frame}
Algorithmus 2. Runde:\\
\begin{enumerate}
\setcounter{enumi}{6}
\item Teilen des Intervalls in (rechtes und) linkes Teilproblem
\end{enumerate}
\begin{columns}
\column{.50\textwidth}
\begin{center}
\includegraphics[height=0.4\textheight]{picture/algo-schritt3.png}
\end{center}
\column{.50\textwidth}
\begin{center}
\includegraphics[height=0.6\textheight]{picture/skyline-left-right2.png}
\end{center}
\end{columns}
\vspace{-5mm}
\end{frame}

\begin{frame}
Algorithmus 2. Runde:\\
\begin{enumerate}
\setcounter{enumi}{7} 
\item In diesem Teilproblem wieder Schritt 1 anwenden.
\end{enumerate}
\begin{columns}
\column{.50\textwidth}
\begin{center}
\includegraphics[height=0.4\textheight]{picture/algo-schritt4.png}
\end{center}
\column{.50\textwidth}
\begin{center}
\includegraphics[height=0.6\textheight]{picture/skyline-left2.png}
\end{center}
\end{columns}
\vspace{-5mm}
\end{frame}

\begin{frame}
Algorithmus 3. Runde:\\
\begin{enumerate}
\setcounter{enumi}{8}
\item Suchen des Minimums im aktuellen Intervall.
\end{enumerate}
\begin{columns}
\column{.50\textwidth}
\begin{center}
\includegraphics[height=0.4\textheight]{picture/algo-schritt1.png}
\end{center}
\column{.50\textwidth}
\begin{center}
\includegraphics[height=0.6\textheight]{picture/skyline-min-find3.png}
\end{center}
\end{columns}
\vspace{-5mm}
\end{frame}

\begin{frame}
Algorithmus 3. Runde:\\
\begin{enumerate}
\setcounter{enumi}{9} 
\item Berechnen der Fläche unterhalb dieses Minimums (jetzt 16)
\end{enumerate}
\begin{columns}
\column{.50\textwidth}
\begin{center}
\includegraphics[height=0.4\textheight]{picture/algo-schritt2.png}
\end{center}
\column{.50\textwidth}
\begin{center}
\includegraphics[height=0.6\textheight]{picture/skyline-area3.png}
\end{center}
\end{columns}
\vspace{-5mm}
\end{frame}

\begin{frame}
Algorithmus 3. Runde:\\
\begin{enumerate}
\setcounter{enumi}{10}
\item Teilen des Intervalls in rechtes (und linkes) Teilproblem
\end{enumerate}
\begin{columns}
\column{.50\textwidth}
\begin{center}
\includegraphics[height=0.4\textheight]{picture/algo-schritt3.png}
\end{center}
\column{.50\textwidth}
\begin{center}
\includegraphics[height=0.6\textheight]{picture/skyline-left-right3.png}
\end{center}
\end{columns}
\vspace{-5mm}
\end{frame}

\begin{frame}
Algorithmus 3. Runde:\\
\begin{enumerate}
\setcounter{enumi}{11} 
\item In diesem Teilproblem wieder Schritt 1 anwenden.
\end{enumerate}
\begin{columns}
\column{.50\textwidth}
\begin{center}
\includegraphics[height=0.4\textheight]{picture/algo-schritt4.png}
\end{center}
\column{.50\textwidth}
\begin{center}
\includegraphics[height=0.6\textheight]{picture/skyline-right3.png}
\end{center}
\end{columns}
\vspace{-5mm}
\end{frame}

\begin{frame}
Algorithmus 4. Runde:\\
\begin{enumerate}
\setcounter{enumi}{12}
\item Suchen des Minimums im aktuellen Intervall.
\end{enumerate}
\begin{columns}
\column{.50\textwidth}
\begin{center}
\includegraphics[height=0.4\textheight]{picture/algo-schritt1.png}
\end{center}
\column{.50\textwidth}
\begin{center}
\includegraphics[height=0.6\textheight]{picture/skyline-min-find4.png}
\end{center}
\end{columns}
\vspace{-5mm}
\end{frame}

\begin{frame}
Algorithmus 4. Runde:\\
\begin{enumerate}
\setcounter{enumi}{13} 
\item Berechnen der Fläche unterhalb dieses Minimums (nur 12)
\end{enumerate}
\begin{columns}
\column{.50\textwidth}
\begin{center}
\includegraphics[height=0.4\textheight]{picture/algo-schritt2.png}
\end{center}
\column{.50\textwidth}
\begin{center}
\includegraphics[height=0.6\textheight]{picture/skyline-area4.png}
\end{center}
\end{columns}
\vspace{-5mm}
\end{frame}

\begin{frame}
Algorithmus 4. Runde:\\
\begin{enumerate}
\setcounter{enumi}{14}
\item Teilen des Intervalls in (rechtes und) linkes Teilproblem
\end{enumerate}
\begin{columns}
\column{.50\textwidth}
\begin{center}
\includegraphics[height=0.4\textheight]{picture/algo-schritt3.png}
\end{center}
\column{.50\textwidth}
\begin{center}
\includegraphics[height=0.6\textheight]{picture/skyline-left-right4.png}
\end{center}
\end{columns}
\vspace{-5mm}
\end{frame}

\begin{frame}
Algorithmus 4. Runde:\\
\begin{enumerate}
\setcounter{enumi}{15} 
\item In diesem Teilproblem wieder Schritt 1 anwenden.
\end{enumerate}
\begin{columns}
\column{.50\textwidth}
\begin{center}
\includegraphics[height=0.4\textheight]{picture/algo-schritt4.png}
\end{center}
\column{.50\textwidth}
\begin{center}
\includegraphics[height=0.6\textheight]{picture/skyline-left4.png}
\end{center}
\end{columns}
\vspace{-5mm}
\end{frame}

\begin{frame}
Algorithmus 5. Runde:\\
\begin{enumerate}
\setcounter{enumi}{16}
\item Suchen des Minimums im aktuellen Intervall.
\end{enumerate}
\begin{columns}
\column{.50\textwidth}
\begin{center}
\includegraphics[height=0.4\textheight]{picture/algo-schritt1.png}
\end{center}
\column{.50\textwidth}
\begin{center}
\includegraphics[height=0.6\textheight]{picture/skyline-min-find5.png}
\end{center}
\end{columns}
\vspace{-5mm}
\end{frame}

\begin{frame}
Algorithmus 5. Runde:\\
\begin{enumerate}
\setcounter{enumi}{17} 
\item Berechnen der Fläche unterhalb dieses Minimums (nur 10)
\end{enumerate}
\begin{columns}
\column{.50\textwidth}
\begin{center}
\includegraphics[height=0.4\textheight]{picture/algo-schritt2.png}
\end{center}
\column{.50\textwidth}
\begin{center}
\includegraphics[height=0.6\textheight]{picture/skyline-area5.png}
\end{center}
\end{columns}
\vspace{-5mm}
\end{frame}

\begin{frame}
Algorithmus Endergebnis:\\
\begin{enumerate}
\setcounter{enumi}{18}
\item usw$\dots\ \Longrightarrow$ maximale Fläche = 16
\end{enumerate}
\begin{center}
\includegraphics[height=0.6\textheight]{picture/skyline-end.png}
\end{center}
\vspace{-5mm}
\end{frame}


\begin{frame}[fragile]
\begin{columns}
\column{.75\textwidth}
\begin{block}{Pseudo-Code}

\alert<1>{\tt{while ( !Q.empty() )\{\\}}
\alert<1>{\tt{\ \ \ \ Interval(left, right) = Q.pop();\\[1.5ex]}}

\only<2->{\alert<2>{\tt{\ \ \ \ min = RMQ( Interval(left, right) );\\[1.5ex]}}}

\only<3->{\alert<3>{\tt{\ \ \ \ area = min * (right - left + 1);\\}}}
\only<3->{\alert<3>{\tt{\ \ \ \ if ( area > max ) max = area;\\[1.5ex]}}}

\only<4->{\alert<4>{\tt{\ \ \ \ Q.add( Intervall(left, min - 1) );\\}}}
\only<4->{\alert<4>{\tt{\ \ \ \ Q.add( Intervall(min + 1, right) );}}}
\end{block}
\column{.3\textwidth}
\begin{center}
\includegraphics<1>[height=0.4\textheight]{picture/algo-schritt4.png}
\includegraphics<2>[height=0.4\textheight]{picture/algo-schritt1.png}
\includegraphics<3>[height=0.4\textheight]{picture/algo-schritt2.png}
\includegraphics<4>[height=0.4\textheight]{picture/algo-schritt3.png}
\end{center}
\end{columns}
\end{frame}

\begin{frame}
ggf. rekursiver Algorithmus von Skyline?
\end{frame}

\subsection{Optimierung}

\begin{frame}
\begin{block}{Idee 0}
 Queue anstatt ArrayList
\end{block}
\pause
\begin{block}{Idee 1}
Überprüfen der aktuellen Fläche, \\
denn gegeben war eine maximal Höhe der Gebäude \\
$\Rightarrow$ falls aktuelle Fläche größer als maximale Höhe, Teilproblem ignorieren
\end{block}

\end{frame}

\begin{frame}

\begin{block}{Idee 2}
Nutzen von CUDA oder OpenCL um 'Sparse Table' in $\Oh(n)$ zu berechnen.

\includegraphics[width=0.2\linewidth]{picture/cuda_opencl_logos} 

\end{block} 

\end{frame}

\subsection{Anwendungen}
\begin{frame}
\begin{itemize}
	\item Lowest Common Ancestor (letzter gemeinsamer Vorfahre)
	\item String matching
\end{itemize}
\end{frame}

\begin{frame}
 \begin{block}{Quellen}
   \url{http://community.topcoder.com/tc?module=Static&d1=tutorials&d2=lowestCommonAncestor}\\
   \url{http://wcipeg.com/wiki/RMQ}\\
   \url{http://www.indigorenderer.com/sites/default/files/cuda_opencl_logos.png}
 \end{block}
\end{frame}

\thispagestyle{empty}


\end{document}
